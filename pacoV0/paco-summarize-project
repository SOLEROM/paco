#!/usr/bin/env python3
"""
paco-summarize-project - Generate/update project summary using LLM
Usage: paco-summarize-project <project> [--archive]
"""

import sys
import argparse
from datetime import datetime
from pathlib import Path
from paco_lib import (
    init_paco_dirs, 
    get_project_dir,
    call_ollama,
    load_tasks
)


def main():
    parser = argparse.ArgumentParser(
        description="Generate or update project summary using LLM"
    )
    parser.add_argument("project", help="Project name")
    parser.add_argument(
        "--archive",
        action="store_true",
        help="Archive old log after summarizing"
    )
    parser.add_argument(
        "--keep-lines",
        type=int,
        default=40,
        help="Number of recent log lines to keep (default: 40)"
    )
    parser.add_argument(
        "--model",
        default="llama3.2",
        help="Ollama model to use (default: llama3.2)"
    )
    
    args = parser.parse_args()
    
    # Initialize PACO dirs
    init_paco_dirs()
    
    project_dir = get_project_dir(args.project)
    log_file = project_dir / "log.md"
    summary_file = project_dir / "summary.md"
    
    if not log_file.exists():
        print(f"Error: No log file found for '{args.project}'", file=sys.stderr)
        sys.exit(1)
    
    print(f"ðŸ“ Summarizing '{args.project}'...")
    
    # Read log and tasks
    log_content = log_file.read_text()
    tasks = load_tasks(args.project, status_filter=None)
    
    # Build context for LLM
    active_tasks = [t for t in tasks if t.get("status") == "active"]
    completed_tasks = [t for t in tasks if t.get("status") == "completed"]
    
    system_prompt = """You are PACO, a personal productivity assistant.
Generate a concise project summary (150-400 words) that includes:
1. Project goal/purpose
2. Recent accomplishments
3. Current blockers or challenges
4. Key next steps

Be specific and actionable. Focus on what matters most."""
    
    user_prompt = f"""Based on the following project information, create a concise summary:

PROJECT LOG:
{log_content}

ACTIVE TASKS ({len(active_tasks)}):
"""
    
    for task in active_tasks[:10]:  # Limit to 10 tasks
        user_prompt += f"- [{task.get('priority', 'medium')}] {task['title']}\n"
    
    if completed_tasks:
        user_prompt += f"\nRECENTLY COMPLETED ({len(completed_tasks)}):\n"
        for task in completed_tasks[-5:]:  # Last 5 completed
            user_prompt += f"- {task['title']}\n"
    
    user_prompt += "\nGenerate a project summary:"
    
    # Call LLM
    print("ðŸ’­ Generating summary...")
    summary = call_ollama(user_prompt, model=args.model, system_prompt=system_prompt)
    
    # Write summary
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
    summary_content = f"""# {args.project} - Summary

*Last updated: {timestamp}*

{summary}
"""
    
    summary_file.write_text(summary_content)
    print(f"âœ“ Summary updated: {summary_file}")
    
    # Archive old log if requested
    if args.archive:
        print("\nðŸ“¦ Archiving old log...")
        
        lines = log_content.strip().split("\n")
        
        if len(lines) > args.keep_lines:
            # Split into archive and keep
            archive_lines = lines[:-args.keep_lines]
            keep_lines = lines[-args.keep_lines:]
            
            # Save archive
            archive_dir = project_dir / "archive"
            archive_dir.mkdir(exist_ok=True)
            
            archive_date = datetime.now().strftime("%Y-%m-%d")
            archive_file = archive_dir / f"log-{archive_date}.md"
            
            archive_file.write_text("\n".join(archive_lines))
            print(f"  âœ“ Archived to: {archive_file}")
            
            # Update main log with recent lines only
            header = f"# {args.project} - Log\n\n*Older entries archived to archive/*\n\n"
            log_file.write_text(header + "\n".join(keep_lines))
            print(f"  âœ“ Kept {len(keep_lines)} recent lines in main log")
        else:
            print(f"  â„¹ Log has only {len(lines)} lines, no archiving needed")
    
    print("\nâœ¨ Done!")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nCancelled.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
